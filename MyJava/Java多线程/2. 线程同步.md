2017/8/17 18:41:20  

# 2. 线程同步

上篇文章说到了多线程的基本知识，包括进程的创建和生命周期。这篇文章会介绍在多线程运行中经常出现的线程安全问题，以及最简单的避免线程安全问题的解决方式。  


## 2.1. synchronized关键字
当多个线程操作共享的数据时，容易发生线程安全问题，可能会对数据进行不正确的操作，这时我们要保证对数据的每个操作的安全。  
Java中解决线程安全的方法是使用同步机制，具体实现是`synchronized`关键字对于可能出现安全问题的代码进行加锁操作。  
首先，解释一下`synchronzied`作用  
`synchronzied`关键字的作用一个词概括就是：线程同步。它可以用来修改对象中的方法，将对象加锁。相当于不管哪一个线程A每次运行到这个方法时,都要检查有没有其它正在用这个方法的线程B（或者C D等）,有的话要等正在使用这个方法的线程B（或者C D）运行完这个方法后再运行此线程A,没有的话,直接运行。  

具体的使用方式有两种：  
1. 同步代码块；  
2. 同步方法。

我们分别来看。  
### 同步代码块
同步代码块的使用方式是：

        synchronized(同步监视器) {
            ... //具体需要同步的代码
        }
        
同步监视器又称为锁，可以由任意一个对象充当。当那个线程获得此监视器，谁就执行同步代码块中的代码。  

同步监视器可以使用 `this` 关键字，代表当前对象操作的对象：

        synchronized(this) {
            // do something...
        }
        
具体什么对象可以作为同步锁呢？不同的锁的范围是否一样呢？  
答案：  
同步监视器一般有两种：类对象（`xx.class`）和一般对象  

(1) 其中类对象的锁是针对此类，如果其中有静态变量的话，那么类对象锁可以对其进行锁定，导致程序执行成功，但是它对实例变量没有用，因为事实上实例变量是对象中的，而对象是对类变量的一份复制，对象中变量的变化不会影响到类变量；  
(2) 对象锁针对的是具体的对象，它可以是随意一个我们新建的对象（这里面包括类对象），或者是`this`关键字代表的当前`Runnable`对象，它针对当前对象作用。  

### 同步方法
同步方法就是在方法名前加synchronized关键字，例如：

        synchronized void method1() {
            //  do something...
        }

方法锁分为两种：静态方法锁和实例方法锁。  

实例方法锁中，锁定的对象是当前对象  
静态方法锁中，锁定的对象时当前的类对象  

两个的区别就是如果多线程执行时，使用实例方法锁有时不会起作用，因为多线程可能回去操作多个对象，这时这个对象都被持有自己的线程作为锁，这样就违背了多线程使用的初衷--操作同一个对象。  
而使用静态方法锁时不会有这样的顾虑，因为它默认锁定当前类对象，而这个类对象是唯一的，可以正常使用多线程。  

## 2.2. 单例模式
此处之前有文章详细说明，不再赘述。
## 2.3. 释放锁 & 不释放锁的操作
释放锁的操作  
当前线程的同步方法、同步代码块执行结束  
当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。  
当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束  
当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。  

小结：不会释放锁的操作

线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行  

线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。  
JDK5.0之后提出应避免使用suspend()和resume()来控制线程，因为可能导致死锁。

## 2.4. 什么是死锁
死锁  
不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁  
解决方法  
专门的算法、原则  
尽量减少同步资源的定义  

ps: 现在的问题是：  
（1）sync(this)时，对象中的静态变量是不是也只能是一个线程进行操作？  
这个答案经过测试是 :如果有非sync方法操作静态变量，有没有sync（this）块都不会影响。

（2）有多个sync方法，有不加锁的方法，如果加锁方法运行时（会操作成员变量）时，不加锁的方法能不能操作成员变量？？
我的意思是：既然有线程已经获得了该对象的锁，那么其它方法能不能通过非sync方法修改其成员变量？

答案是 ： 可以，只有sync方法受影响。